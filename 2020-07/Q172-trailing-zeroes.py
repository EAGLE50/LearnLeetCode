# -*- coding:utf-8 -*-
# @Time : 2020/7/21 22:58 
# @Author : bendan50
# @File : Q172-trailing-zeroes.py 
# @Function : 阶乘后的零
# 给定一个整数 n，返回 n! 结果尾数中零的数量。
# 输入: 3
# 输出: 0
# 解释: 3! = 6, 尾数中没有零。
# 输入: 5
# 输出: 1
# 解释: 5! = 120, 尾数中有 1 个零.
# 你算法的时间复杂度应为O(logn) 。
# @Software: PyCharm

class Solution:
    def trailingZeroes(self, n: int) -> int:
        """
        思路：只有2*5可以产生零，该问题等价于有多少个2和5配对！又因为是阶乘，所以只需要计算5的个数，因为2的个数肯定比5多。
        所以直接 n // 5得出有多少个5。但能直接返回了吗？或者说，这就是正确答案了吗？
        以n=44为例，44//5=8，即有8个5，分别为：5、10、15、20、25、30、35、40
        上述8个值乘以2均会在结尾生成一个0，还会多出0来吗？答案是：是的！多出了一个0
        原因是25这个数，包含了两个5，而不是一个5，即25*2*2=100，产生了两个0，而非一个。
        综上：
        5、10、15、20、25、30、35、40      #44中有8个直接关联的5
        1、2、3、4、5、6、7、8             #8中有1个直接关联的5
        1           #1中有0个直接关联的5，
        :param n:
        :return:
        """
        sum = 0
        while n // 5 > 0:
            n = n // 5
            sum += n
        return sum
        pass

if __name__ == "__main__":
    n = 74
    ret = Solution().trailingZeroes(n)
    print('ret = {}'.format(ret))